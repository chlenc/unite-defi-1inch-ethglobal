import{H as Dt,c as It,a as xt,t as Pt,b as ie,w as se,r as K,d as ce,e as ae,f as fe,g as ue}from"./sha3-DG6CBcqs.js";function le(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const o=BigInt(32),s=BigInt(4294967295),c=Number(t>>o&s),a=Number(t&s),i=r?4:0,u=r?0:4;n.setUint32(e+i,c,r),n.setUint32(e+u,a,r)}function de(n,e,t){return n&e^~n&t}function he(n,e,t){return n&e^n&t^e&t}class we extends Dt{constructor(e,t,r,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=It(this.buffer)}update(e){xt(this);const{view:t,buffer:r,blockLen:o}=this;e=Pt(e);const s=e.length;for(let c=0;c<s;){const a=Math.min(o-this.pos,s-c);if(a===o){const i=It(e);for(;o<=s-c;c+=o)this.process(i,c);continue}r.set(e.subarray(c,c+a),this.pos),this.pos+=a,c+=a,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){xt(this),ie(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:o,isLE:s}=this;let{pos:c}=this;t[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let g=c;g<o;g++)t[g]=0;le(r,o-8,BigInt(this.length*8),s),this.process(r,0);const a=It(e),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=i/4,v=this.get();if(u>v.length)throw new Error("_sha2: outputLen bigger than state");for(let g=0;g<u;g++)a.setUint32(4*g,v[g],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:o,finished:s,destroyed:c,pos:a}=this;return e.length=o,e.pos=a,e.finished=s,e.destroyed=c,o%t&&e.buffer.set(r),e}}const ge=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),X=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Q=new Uint32Array(64);class pe extends we{constructor(){super(64,32,8,!1),this.A=X[0]|0,this.B=X[1]|0,this.C=X[2]|0,this.D=X[3]|0,this.E=X[4]|0,this.F=X[5]|0,this.G=X[6]|0,this.H=X[7]|0}get(){const{A:e,B:t,C:r,D:o,E:s,F:c,G:a,H:i}=this;return[e,t,r,o,s,c,a,i]}set(e,t,r,o,s,c,a,i){this.A=e|0,this.B=t|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=c|0,this.G=a|0,this.H=i|0}process(e,t){for(let g=0;g<16;g++,t+=4)Q[g]=e.getUint32(t,!1);for(let g=16;g<64;g++){const d=Q[g-15],m=Q[g-2],q=K(d,7)^K(d,18)^d>>>3,y=K(m,17)^K(m,19)^m>>>10;Q[g]=y+Q[g-7]+q+Q[g-16]|0}let{A:r,B:o,C:s,D:c,E:a,F:i,G:u,H:v}=this;for(let g=0;g<64;g++){const d=K(a,6)^K(a,11)^K(a,25),m=v+d+de(a,i,u)+ge[g]+Q[g]|0,y=(K(r,2)^K(r,13)^K(r,22))+he(r,o,s)|0;v=u,u=i,i=a,a=c+m|0,c=s,s=o,o=r,r=m+y|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,c=c+this.D|0,a=a+this.E|0,i=i+this.F|0,u=u+this.G|0,v=v+this.H|0,this.set(r,o,s,c,a,i,u,v)}roundClean(){Q.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const We=se(()=>new pe);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Et=BigInt(0),Bt=BigInt(1),ye=BigInt(2);function ot(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function yt(n){if(!ot(n))throw new Error("Uint8Array expected")}function ft(n,e){if(typeof e!="boolean")throw new Error(n+" boolean expected, got "+e)}const me=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function ut(n){yt(n);let e="";for(let t=0;t<n.length;t++)e+=me[n[t]];return e}function at(n){const e=n.toString(16);return e.length&1?"0"+e:e}function Zt(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?Et:BigInt("0x"+n)}const D={_0:48,_9:57,A:65,F:70,a:97,f:102};function Vt(n){if(n>=D._0&&n<=D._9)return n-D._0;if(n>=D.A&&n<=D.F)return n-(D.A-10);if(n>=D.a&&n<=D.f)return n-(D.a-10)}function lt(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const e=n.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(t);for(let o=0,s=0;o<t;o++,s+=2){const c=Vt(n.charCodeAt(s)),a=Vt(n.charCodeAt(s+1));if(c===void 0||a===void 0){const i=n[s]+n[s+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+s)}r[o]=c*16+a}return r}function nt(n){return Zt(ut(n))}function Rt(n){return yt(n),Zt(ut(Uint8Array.from(n).reverse()))}function dt(n,e){return lt(n.toString(16).padStart(e*2,"0"))}function kt(n,e){return dt(n,e).reverse()}function be(n){return lt(at(n))}function F(n,e,t){let r;if(typeof e=="string")try{r=lt(e)}catch(s){throw new Error(n+" must be hex string or Uint8Array, cause: "+s)}else if(ot(e))r=Uint8Array.from(e);else throw new Error(n+" must be hex string or Uint8Array");const o=r.length;if(typeof t=="number"&&o!==t)throw new Error(n+" of length "+t+" expected, got "+o);return r}function pt(...n){let e=0;for(let r=0;r<n.length;r++){const o=n[r];yt(o),e+=o.length}const t=new Uint8Array(e);for(let r=0,o=0;r<n.length;r++){const s=n[r];t.set(s,o),o+=s.length}return t}function xe(n,e){if(n.length!==e.length)return!1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}function Ee(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}const Nt=n=>typeof n=="bigint"&&Et<=n;function vt(n,e,t){return Nt(n)&&Nt(e)&&Nt(t)&&e<=n&&n<t}function rt(n,e,t,r){if(!vt(e,t,r))throw new Error("expected valid "+n+": "+t+" <= n < "+r+", got "+e)}function $t(n){let e;for(e=0;n>Et;n>>=Bt,e+=1);return e}function Be(n,e){return n>>BigInt(e)&Bt}function ve(n,e,t){return n|(t?Bt:Et)<<BigInt(e)}const _t=n=>(ye<<BigInt(n-1))-Bt,Ot=n=>new Uint8Array(n),Mt=n=>Uint8Array.from(n);function Wt(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=Ot(n),o=Ot(n),s=0;const c=()=>{r.fill(1),o.fill(0),s=0},a=(...g)=>t(o,r,...g),i=(g=Ot())=>{o=a(Mt([0]),g),r=a(),g.length!==0&&(o=a(Mt([1]),g),r=a())},u=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let g=0;const d=[];for(;g<e;){r=a();const m=r.slice();d.push(m),g+=r.length}return pt(...d)};return(g,d)=>{c(),i(g);let m;for(;!(m=d(u()));)i();return c(),m}}const Se={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||ot(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,e)=>e.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function mt(n,e,t={}){const r=(o,s,c)=>{const a=Se[s];if(typeof a!="function")throw new Error("invalid validator function");const i=n[o];if(!(c&&i===void 0)&&!a(i,n))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+i)};for(const[o,s]of Object.entries(e))r(o,s,!1);for(const[o,s]of Object.entries(t))r(o,s,!0);return n}const Ae=()=>{throw new Error("not implemented")};function Tt(n){const e=new WeakMap;return(t,...r)=>{const o=e.get(t);if(o!==void 0)return o;const s=n(t,...r);return e.set(t,s),s}}const Ie=Object.freeze(Object.defineProperty({__proto__:null,aInRange:rt,abool:ft,abytes:yt,bitGet:Be,bitLen:$t,bitMask:_t,bitSet:ve,bytesToHex:ut,bytesToNumberBE:nt,bytesToNumberLE:Rt,concatBytes:pt,createHmacDrbg:Wt,ensureBytes:F,equalBytes:xe,hexToBytes:lt,hexToNumber:Zt,inRange:vt,isBytes:ot,memoized:Tt,notImplemented:Ae,numberToBytesBE:dt,numberToBytesLE:kt,numberToHexUnpadded:at,numberToVarBytesBE:be,utf8ToBytes:Ee,validateObject:mt},Symbol.toStringTag,{value:"Module"}));class Xt extends Dt{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,ce(e);const r=Pt(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?e.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=e.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),s.fill(0)}update(e){return xt(this),this.iHash.update(e),this}digestInto(e){xt(this),ae(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:o,destroyed:s,blockLen:c,outputLen:a}=this;return e=e,e.finished=o,e.destroyed=s,e.blockLen=c,e.outputLen=a,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Qt=(n,e,t)=>new Xt(n,e).update(t).digest();Qt.create=(n,e)=>new Xt(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Z=BigInt(0),T=BigInt(1),et=BigInt(2),Ne=BigInt(3),zt=BigInt(4),jt=BigInt(5),Yt=BigInt(8);function j(n,e){const t=n%e;return t>=Z?t:e+t}function Oe(n,e,t){if(e<Z)throw new Error("invalid exponent, negatives unsupported");if(t<=Z)throw new Error("invalid modulus");if(t===T)return Z;let r=T;for(;e>Z;)e&T&&(r=r*n%t),n=n*n%t,e>>=T;return r}function Xe(n,e,t){let r=n;for(;e-- >Z;)r*=r,r%=t;return r}function Ct(n,e){if(n===Z)throw new Error("invert: expected non-zero number");if(e<=Z)throw new Error("invert: expected positive modulus, got "+e);let t=j(n,e),r=e,o=Z,s=T;for(;t!==Z;){const a=r/t,i=r%t,u=o-s*a;r=t,t=i,o=s,s=u}if(r!==T)throw new Error("invert: does not exist");return j(o,e)}function qe(n){const e=(n-T)/et;let t,r,o;for(t=n-T,r=0;t%et===Z;t/=et,r++);for(o=et;o<n&&Oe(o,e,n)!==n-T;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const c=(n+T)/zt;return function(i,u){const v=i.pow(u,c);if(!i.eql(i.sqr(v),u))throw new Error("Cannot find square root");return v}}const s=(t+T)/et;return function(a,i){if(a.pow(i,e)===a.neg(a.ONE))throw new Error("Cannot find square root");let u=r,v=a.pow(a.mul(a.ONE,o),t),g=a.pow(i,s),d=a.pow(i,t);for(;!a.eql(d,a.ONE);){if(a.eql(d,a.ZERO))return a.ZERO;let m=1;for(let y=a.sqr(d);m<u&&!a.eql(y,a.ONE);m++)y=a.sqr(y);const q=a.pow(v,T<<BigInt(u-m-1));v=a.sqr(q),g=a.mul(g,q),d=a.mul(d,v),u=m}return g}}function He(n){if(n%zt===Ne){const e=(n+T)/zt;return function(r,o){const s=r.pow(o,e);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(n%Yt===jt){const e=(n-jt)/Yt;return function(r,o){const s=r.mul(o,et),c=r.pow(s,e),a=r.mul(o,c),i=r.mul(r.mul(a,et),c),u=r.mul(a,r.sub(i,r.ONE));if(!r.eql(r.sqr(u),o))throw new Error("Cannot find square root");return u}}return qe(n)}const Le=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ue(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Le.reduce((r,o)=>(r[o]="function",r),e);return mt(n,t)}function Te(n,e,t){if(t<Z)throw new Error("invalid exponent, negatives unsupported");if(t===Z)return n.ONE;if(t===T)return e;let r=n.ONE,o=e;for(;t>Z;)t&T&&(r=n.mul(r,o)),o=n.sqr(o),t>>=T;return r}function ze(n,e){const t=new Array(e.length),r=e.reduce((s,c,a)=>n.is0(c)?s:(t[a]=s,n.mul(s,c)),n.ONE),o=n.inv(r);return e.reduceRight((s,c,a)=>n.is0(c)?s:(t[a]=n.mul(s,t[a]),n.mul(s,c)),o),t}function Jt(n,e){const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Ce(n,e,t=!1,r={}){if(n<=Z)throw new Error("invalid field: expected ORDER > 0, got "+n);const{nBitLength:o,nByteLength:s}=Jt(n,e);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const a=Object.freeze({ORDER:n,isLE:t,BITS:o,BYTES:s,MASK:_t(o),ZERO:Z,ONE:T,create:i=>j(i,n),isValid:i=>{if(typeof i!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof i);return Z<=i&&i<n},is0:i=>i===Z,isOdd:i=>(i&T)===T,neg:i=>j(-i,n),eql:(i,u)=>i===u,sqr:i=>j(i*i,n),add:(i,u)=>j(i+u,n),sub:(i,u)=>j(i-u,n),mul:(i,u)=>j(i*u,n),pow:(i,u)=>Te(a,i,u),div:(i,u)=>j(i*Ct(u,n),n),sqrN:i=>i*i,addN:(i,u)=>i+u,subN:(i,u)=>i-u,mulN:(i,u)=>i*u,inv:i=>Ct(i,n),sqrt:r.sqrt||(i=>(c||(c=He(n)),c(a,i))),invertBatch:i=>ze(a,i),cmov:(i,u,v)=>v?u:i,toBytes:i=>t?kt(i,s):dt(i,s),fromBytes:i=>{if(i.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+i.length);return t?Rt(i):nt(i)}});return Object.freeze(a)}function te(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function ee(n){const e=te(n);return e+Math.ceil(e/2)}function Ze(n,e,t=!1){const r=n.length,o=te(e),s=ee(e);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const c=t?Rt(n):nt(n),a=j(c,e-T)+T;return t?kt(a,o):dt(a,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ft=BigInt(0),bt=BigInt(1);function qt(n,e){const t=e.negate();return n?t:e}function ne(n,e){if(!Number.isSafeInteger(n)||n<=0||n>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+n)}function Ht(n,e){ne(n,e);const t=Math.ceil(e/n)+1,r=2**(n-1);return{windows:t,windowSize:r}}function Re(n,e){if(!Array.isArray(n))throw new Error("array expected");n.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})}function ke(n,e){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}const Lt=new WeakMap,re=new WeakMap;function Ut(n){return re.get(n)||1}function _e(n,e){return{constTimeNegate:qt,hasPrecomputes(t){return Ut(t)!==1},unsafeLadder(t,r,o=n.ZERO){let s=t;for(;r>Ft;)r&bt&&(o=o.add(s)),s=s.double(),r>>=bt;return o},precomputeWindow(t,r){const{windows:o,windowSize:s}=Ht(r,e),c=[];let a=t,i=a;for(let u=0;u<o;u++){i=a,c.push(i);for(let v=1;v<s;v++)i=i.add(a),c.push(i);a=i.double()}return c},wNAF(t,r,o){const{windows:s,windowSize:c}=Ht(t,e);let a=n.ZERO,i=n.BASE;const u=BigInt(2**t-1),v=2**t,g=BigInt(t);for(let d=0;d<s;d++){const m=d*c;let q=Number(o&u);o>>=g,q>c&&(q-=v,o+=bt);const y=m,f=m+Math.abs(q)-1,h=d%2!==0,b=q<0;q===0?i=i.add(qt(h,r[y])):a=a.add(qt(b,r[f]))}return{p:a,f:i}},wNAFUnsafe(t,r,o,s=n.ZERO){const{windows:c,windowSize:a}=Ht(t,e),i=BigInt(2**t-1),u=2**t,v=BigInt(t);for(let g=0;g<c;g++){const d=g*a;if(o===Ft)break;let m=Number(o&i);if(o>>=v,m>a&&(m-=u,o+=bt),m===0)continue;let q=r[d+Math.abs(m)-1];m<0&&(q=q.negate()),s=s.add(q)}return s},getPrecomputes(t,r,o){let s=Lt.get(r);return s||(s=this.precomputeWindow(r,t),t!==1&&Lt.set(r,o(s))),s},wNAFCached(t,r,o){const s=Ut(t);return this.wNAF(s,this.getPrecomputes(s,t,o),r)},wNAFCachedUnsafe(t,r,o,s){const c=Ut(t);return c===1?this.unsafeLadder(t,r,s):this.wNAFUnsafe(c,this.getPrecomputes(c,t,o),r,s)},setWindowSize(t,r){ne(r,e),re.set(t,r),Lt.delete(t)}}}function Ve(n,e,t,r){if(Re(t,n),ke(r,e),t.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=n.ZERO,s=$t(BigInt(t.length)),c=s>12?s-3:s>4?s-2:s?2:1,a=(1<<c)-1,i=new Array(a+1).fill(o),u=Math.floor((e.BITS-1)/c)*c;let v=o;for(let g=u;g>=0;g-=c){i.fill(o);for(let m=0;m<r.length;m++){const q=r[m],y=Number(q>>BigInt(g)&BigInt(a));i[y]=i[y].add(t[m])}let d=o;for(let m=i.length-1,q=o;m>0;m--)q=q.add(i[m]),d=d.add(q);if(v=v.add(d),g!==0)for(let m=0;m<c;m++)v=v.double()}return v}function oe(n){return Ue(n.Fp),mt(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Jt(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Kt(n){n.lowS!==void 0&&ft("lowS",n.lowS),n.prehash!==void 0&&ft("prehash",n.prehash)}function Me(n){const e=oe(n);mt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:o}=e;if(t){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:je,hexToBytes:Ye}=Ie;class Fe extends Error{constructor(e=""){super(e)}}const P={Err:Fe,_tlv:{encode:(n,e)=>{const{Err:t}=P;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const r=e.length/2,o=at(r);if(o.length/2&128)throw new t("tlv.encode: long form length too big");const s=r>127?at(o.length/2|128):"";return at(n)+s+o+e},decode(n,e){const{Err:t}=P;let r=0;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[r++]!==n)throw new t("tlv.decode: wrong tlv");const o=e[r++],s=!!(o&128);let c=0;if(!s)c=o;else{const i=o&127;if(!i)throw new t("tlv.decode(long): indefinite length not supported");if(i>4)throw new t("tlv.decode(long): byte length is too big");const u=e.subarray(r,r+i);if(u.length!==i)throw new t("tlv.decode: length bytes not complete");if(u[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const v of u)c=c<<8|v;if(r+=i,c<128)throw new t("tlv.decode(long): not minimal encoding")}const a=e.subarray(r,r+c);if(a.length!==c)throw new t("tlv.decode: wrong value length");return{v:a,l:e.subarray(r+c)}}},_int:{encode(n){const{Err:e}=P;if(n<$)throw new e("integer: negative integers are not allowed");let t=at(n);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(n){const{Err:e}=P;if(n[0]&128)throw new e("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return je(n)}},toSig(n){const{Err:e,_int:t,_tlv:r}=P,o=typeof n=="string"?Ye(n):n;yt(o);const{v:s,l:c}=r.decode(48,o);if(c.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:i}=r.decode(2,s),{v:u,l:v}=r.decode(2,i);if(v.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(u)}},hexFromSig(n){const{_tlv:e,_int:t}=P,r=e.encode(2,t.encode(n.r)),o=e.encode(2,t.encode(n.s)),s=r+o;return e.encode(48,s)}},$=BigInt(0),C=BigInt(1);BigInt(2);const Gt=BigInt(3);BigInt(4);function Ke(n){const e=Me(n),{Fp:t}=e,r=Ce(e.n,e.nBitLength),o=e.toBytes||((y,f,h)=>{const b=f.toAffine();return pt(Uint8Array.from([4]),t.toBytes(b.x),t.toBytes(b.y))}),s=e.fromBytes||(y=>{const f=y.subarray(1),h=t.fromBytes(f.subarray(0,t.BYTES)),b=t.fromBytes(f.subarray(t.BYTES,2*t.BYTES));return{x:h,y:b}});function c(y){const{a:f,b:h}=e,b=t.sqr(y),B=t.mul(b,y);return t.add(t.add(B,t.mul(y,f)),h)}if(!t.eql(t.sqr(e.Gy),c(e.Gx)))throw new Error("bad generator point: equation left != right");function a(y){return vt(y,C,e.n)}function i(y){const{allowedPrivateKeyLengths:f,nByteLength:h,wrapPrivateKey:b,n:B}=e;if(f&&typeof y!="bigint"){if(ot(y)&&(y=ut(y)),typeof y!="string"||!f.includes(y.length))throw new Error("invalid private key");y=y.padStart(h*2,"0")}let I;try{I=typeof y=="bigint"?y:nt(F("private key",y,h))}catch{throw new Error("invalid private key, expected hex or "+h+" bytes, got "+typeof y)}return b&&(I=j(I,B)),rt("private key",I,C,B),I}function u(y){if(!(y instanceof d))throw new Error("ProjectivePoint expected")}const v=Tt((y,f)=>{const{px:h,py:b,pz:B}=y;if(t.eql(B,t.ONE))return{x:h,y:b};const I=y.is0();f==null&&(f=I?t.ONE:t.inv(B));const L=t.mul(h,f),N=t.mul(b,f),x=t.mul(B,f);if(I)return{x:t.ZERO,y:t.ZERO};if(!t.eql(x,t.ONE))throw new Error("invZ was invalid");return{x:L,y:N}}),g=Tt(y=>{if(y.is0()){if(e.allowInfinityPoint&&!t.is0(y.py))return;throw new Error("bad point: ZERO")}const{x:f,y:h}=y.toAffine();if(!t.isValid(f)||!t.isValid(h))throw new Error("bad point: x or y not FE");const b=t.sqr(h),B=c(f);if(!t.eql(b,B))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(f,h,b){if(this.px=f,this.py=h,this.pz=b,f==null||!t.isValid(f))throw new Error("x required");if(h==null||!t.isValid(h))throw new Error("y required");if(b==null||!t.isValid(b))throw new Error("z required");Object.freeze(this)}static fromAffine(f){const{x:h,y:b}=f||{};if(!f||!t.isValid(h)||!t.isValid(b))throw new Error("invalid affine point");if(f instanceof d)throw new Error("projective point not allowed");const B=I=>t.eql(I,t.ZERO);return B(h)&&B(b)?d.ZERO:new d(h,b,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const h=t.invertBatch(f.map(b=>b.pz));return f.map((b,B)=>b.toAffine(h[B])).map(d.fromAffine)}static fromHex(f){const h=d.fromAffine(s(F("pointHex",f)));return h.assertValidity(),h}static fromPrivateKey(f){return d.BASE.multiply(i(f))}static msm(f,h){return Ve(d,r,f,h)}_setWindowSize(f){q.setWindowSize(this,f)}assertValidity(){g(this)}hasEvenY(){const{y:f}=this.toAffine();if(t.isOdd)return!t.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){u(f);const{px:h,py:b,pz:B}=this,{px:I,py:L,pz:N}=f,x=t.eql(t.mul(h,N),t.mul(I,B)),A=t.eql(t.mul(b,N),t.mul(L,B));return x&&A}negate(){return new d(this.px,t.neg(this.py),this.pz)}double(){const{a:f,b:h}=e,b=t.mul(h,Gt),{px:B,py:I,pz:L}=this;let N=t.ZERO,x=t.ZERO,A=t.ZERO,E=t.mul(B,B),R=t.mul(I,I),U=t.mul(L,L),H=t.mul(B,I);return H=t.add(H,H),A=t.mul(B,L),A=t.add(A,A),N=t.mul(f,A),x=t.mul(b,U),x=t.add(N,x),N=t.sub(R,x),x=t.add(R,x),x=t.mul(N,x),N=t.mul(H,N),A=t.mul(b,A),U=t.mul(f,U),H=t.sub(E,U),H=t.mul(f,H),H=t.add(H,A),A=t.add(E,E),E=t.add(A,E),E=t.add(E,U),E=t.mul(E,H),x=t.add(x,E),U=t.mul(I,L),U=t.add(U,U),E=t.mul(U,H),N=t.sub(N,E),A=t.mul(U,R),A=t.add(A,A),A=t.add(A,A),new d(N,x,A)}add(f){u(f);const{px:h,py:b,pz:B}=this,{px:I,py:L,pz:N}=f;let x=t.ZERO,A=t.ZERO,E=t.ZERO;const R=e.a,U=t.mul(e.b,Gt);let H=t.mul(h,I),M=t.mul(b,L),l=t.mul(B,N),w=t.add(h,b),p=t.add(I,L);w=t.mul(w,p),p=t.add(H,M),w=t.sub(w,p),p=t.add(h,B);let S=t.add(I,N);return p=t.mul(p,S),S=t.add(H,l),p=t.sub(p,S),S=t.add(b,B),x=t.add(L,N),S=t.mul(S,x),x=t.add(M,l),S=t.sub(S,x),E=t.mul(R,p),x=t.mul(U,l),E=t.add(x,E),x=t.sub(M,E),E=t.add(M,E),A=t.mul(x,E),M=t.add(H,H),M=t.add(M,H),l=t.mul(R,l),p=t.mul(U,p),M=t.add(M,l),l=t.sub(H,l),l=t.mul(R,l),p=t.add(p,l),H=t.mul(M,p),A=t.add(A,H),H=t.mul(S,p),x=t.mul(w,x),x=t.sub(x,H),H=t.mul(w,M),E=t.mul(S,E),E=t.add(E,H),new d(x,A,E)}subtract(f){return this.add(f.negate())}is0(){return this.equals(d.ZERO)}wNAF(f){return q.wNAFCached(this,f,d.normalizeZ)}multiplyUnsafe(f){const{endo:h,n:b}=e;rt("scalar",f,$,b);const B=d.ZERO;if(f===$)return B;if(this.is0()||f===C)return this;if(!h||q.hasPrecomputes(this))return q.wNAFCachedUnsafe(this,f,d.normalizeZ);let{k1neg:I,k1:L,k2neg:N,k2:x}=h.splitScalar(f),A=B,E=B,R=this;for(;L>$||x>$;)L&C&&(A=A.add(R)),x&C&&(E=E.add(R)),R=R.double(),L>>=C,x>>=C;return I&&(A=A.negate()),N&&(E=E.negate()),E=new d(t.mul(E.px,h.beta),E.py,E.pz),A.add(E)}multiply(f){const{endo:h,n:b}=e;rt("scalar",f,C,b);let B,I;if(h){const{k1neg:L,k1:N,k2neg:x,k2:A}=h.splitScalar(f);let{p:E,f:R}=this.wNAF(N),{p:U,f:H}=this.wNAF(A);E=q.constTimeNegate(L,E),U=q.constTimeNegate(x,U),U=new d(t.mul(U.px,h.beta),U.py,U.pz),B=E.add(U),I=R.add(H)}else{const{p:L,f:N}=this.wNAF(f);B=L,I=N}return d.normalizeZ([B,I])[0]}multiplyAndAddUnsafe(f,h,b){const B=d.BASE,I=(N,x)=>x===$||x===C||!N.equals(B)?N.multiplyUnsafe(x):N.multiply(x),L=I(this,h).add(I(f,b));return L.is0()?void 0:L}toAffine(f){return v(this,f)}isTorsionFree(){const{h:f,isTorsionFree:h}=e;if(f===C)return!0;if(h)return h(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:h}=e;return f===C?this:h?h(d,this):this.multiplyUnsafe(e.h)}toRawBytes(f=!0){return ft("isCompressed",f),this.assertValidity(),o(d,this,f)}toHex(f=!0){return ft("isCompressed",f),ut(this.toRawBytes(f))}}d.BASE=new d(e.Gx,e.Gy,t.ONE),d.ZERO=new d(t.ZERO,t.ONE,t.ZERO);const m=e.nBitLength,q=_e(d,e.endo?Math.ceil(m/2):m);return{CURVE:e,ProjectivePoint:d,normPrivateKeyToScalar:i,weierstrassEquation:c,isWithinCurveOrder:a}}function Ge(n){const e=oe(n);return mt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function De(n){const e=Ge(n),{Fp:t,n:r}=e,o=t.BYTES+1,s=2*t.BYTES+1;function c(l){return j(l,r)}function a(l){return Ct(l,r)}const{ProjectivePoint:i,normPrivateKeyToScalar:u,weierstrassEquation:v,isWithinCurveOrder:g}=Ke({...e,toBytes(l,w,p){const S=w.toAffine(),O=t.toBytes(S.x),z=pt;return ft("isCompressed",p),p?z(Uint8Array.from([w.hasEvenY()?2:3]),O):z(Uint8Array.from([4]),O,t.toBytes(S.y))},fromBytes(l){const w=l.length,p=l[0],S=l.subarray(1);if(w===o&&(p===2||p===3)){const O=nt(S);if(!vt(O,C,t.ORDER))throw new Error("Point is not on curve");const z=v(O);let _;try{_=t.sqrt(z)}catch(Y){const V=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+V)}const k=(_&C)===C;return(p&1)===1!==k&&(_=t.neg(_)),{x:O,y:_}}else if(w===s&&p===4){const O=t.fromBytes(S.subarray(0,t.BYTES)),z=t.fromBytes(S.subarray(t.BYTES,2*t.BYTES));return{x:O,y:z}}else{const O=o,z=s;throw new Error("invalid Point, expected length of "+O+", or uncompressed "+z+", got "+w)}}}),d=l=>ut(dt(l,e.nByteLength));function m(l){const w=r>>C;return l>w}function q(l){return m(l)?c(-l):l}const y=(l,w,p)=>nt(l.slice(w,p));class f{constructor(w,p,S){this.r=w,this.s=p,this.recovery=S,this.assertValidity()}static fromCompact(w){const p=e.nByteLength;return w=F("compactSignature",w,p*2),new f(y(w,0,p),y(w,p,2*p))}static fromDER(w){const{r:p,s:S}=P.toSig(F("DER",w));return new f(p,S)}assertValidity(){rt("r",this.r,C,r),rt("s",this.s,C,r)}addRecoveryBit(w){return new f(this.r,this.s,w)}recoverPublicKey(w){const{r:p,s:S,recovery:O}=this,z=N(F("msgHash",w));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const _=O===2||O===3?p+e.n:p;if(_>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const k=O&1?"03":"02",G=i.fromHex(k+d(_)),Y=a(_),V=c(-z*Y),it=c(S*Y),W=i.BASE.multiplyAndAddUnsafe(G,V,it);if(!W)throw new Error("point at infinify");return W.assertValidity(),W}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new f(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return lt(this.toDERHex())}toDERHex(){return P.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return lt(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const h={isValidPrivateKey(l){try{return u(l),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const l=ee(e.n);return Ze(e.randomBytes(l),e.n)},precompute(l=8,w=i.BASE){return w._setWindowSize(l),w.multiply(BigInt(3)),w}};function b(l,w=!0){return i.fromPrivateKey(l).toRawBytes(w)}function B(l){const w=ot(l),p=typeof l=="string",S=(w||p)&&l.length;return w?S===o||S===s:p?S===2*o||S===2*s:l instanceof i}function I(l,w,p=!0){if(B(l))throw new Error("first arg must be private key");if(!B(w))throw new Error("second arg must be public key");return i.fromHex(w).multiply(u(l)).toRawBytes(p)}const L=e.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const w=nt(l),p=l.length*8-e.nBitLength;return p>0?w>>BigInt(p):w},N=e.bits2int_modN||function(l){return c(L(l))},x=_t(e.nBitLength);function A(l){return rt("num < 2^"+e.nBitLength,l,$,x),dt(l,e.nByteLength)}function E(l,w,p=R){if(["recovered","canonical"].some(J=>J in p))throw new Error("sign() legacy options not supported");const{hash:S,randomBytes:O}=e;let{lowS:z,prehash:_,extraEntropy:k}=p;z==null&&(z=!0),l=F("msgHash",l),Kt(p),_&&(l=F("prehashed msgHash",S(l)));const G=N(l),Y=u(w),V=[A(Y),A(G)];if(k!=null&&k!==!1){const J=k===!0?O(t.BYTES):k;V.push(F("extraEntropy",J))}const it=pt(...V),W=G;function St(J){const st=L(J);if(!g(st))return;const At=a(st),ht=i.BASE.multiply(st).toAffine(),tt=c(ht.x);if(tt===$)return;const wt=c(At*c(W+tt*Y));if(wt===$)return;let gt=(ht.x===tt?0:2)|Number(ht.y&C),ct=wt;return z&&m(wt)&&(ct=q(wt),gt^=1),new f(tt,ct,gt)}return{seed:it,k2sig:St}}const R={lowS:e.lowS,prehash:!1},U={lowS:e.lowS,prehash:!1};function H(l,w,p=R){const{seed:S,k2sig:O}=E(l,w,p),z=e;return Wt(z.hash.outputLen,z.nByteLength,z.hmac)(S,O)}i.BASE._setWindowSize(8);function M(l,w,p,S=U){var gt;const O=l;w=F("msgHash",w),p=F("publicKey",p);const{lowS:z,prehash:_,format:k}=S;if(Kt(S),"strict"in S)throw new Error("options.strict was renamed to lowS");if(k!==void 0&&k!=="compact"&&k!=="der")throw new Error("format must be compact or der");const G=typeof O=="string"||ot(O),Y=!G&&!k&&typeof O=="object"&&O!==null&&typeof O.r=="bigint"&&typeof O.s=="bigint";if(!G&&!Y)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let V,it;try{if(Y&&(V=new f(O.r,O.s)),G){try{k!=="compact"&&(V=f.fromDER(O))}catch(ct){if(!(ct instanceof P.Err))throw ct}!V&&k!=="der"&&(V=f.fromCompact(O))}it=i.fromHex(p)}catch{return!1}if(!V||z&&V.hasHighS())return!1;_&&(w=e.hash(w));const{r:W,s:St}=V,J=N(w),st=a(St),At=c(J*st),ht=c(W*st),tt=(gt=i.BASE.multiplyAndAddUnsafe(it,At,ht))==null?void 0:gt.toAffine();return tt?c(tt.x)===W:!1}return{CURVE:e,getPublicKey:b,getSharedSecret:I,sign:H,verify:M,ProjectivePoint:i,Signature:f,utils:h}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Pe(n){return{hash:n,hmac:(e,...t)=>Qt(n,e,ue(...t)),randomBytes:fe}}function Qe(n,e){const t=r=>De({...n,...Pe(r)});return{...t(e),create:t}}export{Ce as F,we as H,Qe as c,j as m,Xe as p,We as s};
